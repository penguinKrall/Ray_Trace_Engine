#version 460

#extension GL_EXT_ray_tracing : enable
#extension GL_GOOGLE_include_directive : require

struct RayPayload {
    vec3 color;
    float distance;
    vec3 normal;
    float reflector;
    vec4 accumulatedColor;
    float accumulatedAlpha;
    float index;
		vec3 bgTest;
		int semiTransparentFlag;
		vec4 colorID;
};

layout(location = 0) rayPayloadEXT RayPayload rayPayload;

layout(binding = 0, set = 0) uniform accelerationStructureEXT topLevelAS;

layout(binding = 1, set = 0, rgba8) uniform image2D image;
layout(binding = 2, set = 0, rgba8) uniform image2D objectIDImage;

layout(binding = 3, set = 0) uniform CameraProperties  {
    mat4 viewInverse;
    mat4 projInverse;
    vec4 lightPos;
} cam;

// Max. number of recursion is passed via a specialization constant
layout (constant_id = 0) const int MAX_RECURSION = 4;

#include "main_renderer_random.glsl"

void main(){
	//uint instanceCustomIndex = gl_InstanceCustomIndexEXT;
				//fov?
				float tmin = 0.001;
				float tmax = 100.0;

				vec3 hitValues = vec3(0.0f);

		    // Initialize payload
		    rayPayload.accumulatedColor = vec4(0.0);
		    rayPayload.accumulatedAlpha = 0.0;
		    rayPayload.distance = 1.0f;
		    rayPayload.reflector = 1.0f;
		    rayPayload.normal = vec3(1.0f);
				//rayPayload.colorID = 0.0f;
				bool isColorIDImageStored = false;

				//ray coords
				const vec2 pixelCenter = vec2(gl_LaunchIDEXT.xy) + vec2(0.5);
				const vec2 inUV = pixelCenter/vec2(gl_LaunchSizeEXT.xy);
				vec2 d = inUV * 2.0 - 1.0;

				//view
				vec4 origin = cam.viewInverse * vec4(0,0,0,1);

				//projection
				vec4 target = cam.projInverse * vec4(d.x, d.y, 1, 1) ;

				//view direction
				vec4 direction = cam.viewInverse * vec4(normalize(target.xyz), 0);

				//reflections

						for (int i = 0; i < MAX_RECURSION; i++) {
										
										// trace rays opaque to get all color
										traceRayEXT(topLevelAS, gl_RayFlagsOpaqueEXT, 0xff, 0, 0, 0, origin.xyz, tmin, direction.xyz, tmax, 0);
										
										// store object id image without transparency trace
										if(!isColorIDImageStored){
												imageStore(objectIDImage, ivec2(gl_LaunchIDEXT.xy), vec4(rayPayload.colorID.rgb, 1.0f));
												isColorIDImageStored = true;
										}

										// transparency ray trace
										if(rayPayload.semiTransparentFlag == 1){
												traceRayEXT(topLevelAS, gl_RayFlagsNoneEXT, 0xff, 0, 0, 0, origin.xyz, tmin, direction.xyz, tmax, 0);
										}

										vec3 hitColor = rayPayload.color;
										float hitAlpha = rayPayload.accumulatedAlpha;

										// Composite the hit color with the accumulated color
										rayPayload.accumulatedAlpha += hitAlpha * (1.0 - rayPayload.accumulatedAlpha);
										rayPayload.accumulatedColor = vec4(mix(rayPayload.accumulatedColor.rgb, hitColor, hitAlpha * (1.0 - rayPayload.accumulatedAlpha)),rayPayload.accumulatedAlpha);

										if (rayPayload.distance < 0.0f) {
											hitValues += mix(hitColor, rayPayload.accumulatedColor.rgb, 0.5f);
											break;
										} 

										else if (rayPayload.reflector == 1.0f) {
											const vec4 hitPos = origin + direction * rayPayload.distance;
											origin.xyz = hitPos.xyz + rayPayload.normal * 0.001f;
											direction.xyz = reflect(direction.xyz, rayPayload.normal);
										} 

										else {
											hitValues += mix(hitColor, rayPayload.accumulatedColor.rgb, 0.5f);
											break;
										}
								}

				vec3 hitVal = hitValues;

				imageStore(image, ivec2(gl_LaunchIDEXT.xy), vec4(hitVal, 1.0f));


}
