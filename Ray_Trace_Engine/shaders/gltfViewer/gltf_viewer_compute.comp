#version 450

//workgroup size
layout(local_size_x = 256) in;

//vertex struct
struct Vtx {
    vec4 position;
    vec4 normal;
    vec2 uv;
    float padding;
    float padding2;
    vec4 inColor;
    vec4 inJointIndices;
    vec4 inJointWeights;
    vec4 tangent;
};

//joint struct (bones/transformation matrices)
struct Joints{
    mat4 joint;
};

// Define storage buffer layout for input vertices and joint data
layout(std140, binding = 0) buffer InputSSBO {
    Vtx vtx[];
}inputSSBO;

// Define storage buffer layout for output vertices
layout(std140, binding = 1) buffer OutputSSBOData {
    Vtx vtx[];
}outputSSBO;

// Define storage buffer layout for joints
layout(std140, binding = 2) buffer JointSSBOData {
    Joints joints[100]; // Assuming a maximum of 20 joints
}jointSSBO;


void main() {
    
    //index for vertex buffer
    uint vID = gl_GlobalInvocationID.x;

    //break if index > vertex buffer length
    if (vID > inputSSBO.vtx.length()) {
        return;
    }

    //declare vertex struct variable and assign value from vertex buffer
    Vtx v = outputSSBO.vtx[vID];

    //rotation matrix to rotate vertex around x axis
    //float angle = radians(90.0); // Adjust the angle as needed
    //mat4 rotationMatrix = mat4(1.0);
    //rotationMatrix[1][1] = cos(angle);
    //rotationMatrix[1][2] = -sin(angle);
    //rotationMatrix[2][1] = sin(angle);
    //rotationMatrix[2][2] = cos(angle);

    //joint indices
    ivec4 vJoints = ivec4(int(v.inJointIndices.x), int(v.inJointIndices.y), int(v.inJointIndices.z), int(v.inJointIndices.w));
    
    //weights
    vec4 vWeights = v.inJointWeights;
    
    //joint matrices(bones)
    Joints vBones[100] = jointSSBO.joints;

    //transformation matrix
    mat4 transform = 
    vWeights.x * vBones[vJoints.x].joint+
    vWeights.y * vBones[vJoints.y].joint+
    vWeights.z * vBones[vJoints.z].joint+
    vWeights.w * vBones[vJoints.w].joint;
    
    //apply rotation and transformation matrices
    //position
    vec4 newPosition = transform * vec4(v.position.xyz, 1.0f);
    v.position = vec4(newPosition.x, newPosition.y, newPosition.z, 1.0f);
    
    //normal
    v.normal = normalize(transform * v.normal);
    
    //tangent
    float w = v.tangent.w;
    v.tangent = normalize((transform * vec4(v.tangent.xyz, 1.0f)));
    v.tangent.w = w;
    
    //assign declared vertex variable data to vertex
    inputSSBO.vtx[vID] = v;


}