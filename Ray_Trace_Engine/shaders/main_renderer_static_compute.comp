#version 450

#extension GL_EXT_debug_printf : enable
#extension GL_EXT_nonuniform_qualifier : require

//workgroup size
layout(local_size_x = 256) in;

//vertex struct
struct Vtx {
    vec4 position;
    vec4 normal;
    vec2 uv;
    float padding;
    float padding2;
    vec4 inColor;
    vec4 inJointIndices;
    vec4 inJointWeights;
    vec4 tangent;
};

//transforms struct
struct TransformMatrices{
    mat4 rotate;
    mat4 translate;
    mat4 scale;
};

//model vertex buffer
layout(std140, binding = 0) buffer ModelVertexBufferWrite {
    Vtx vtx[];
}modelVertexBufferWrite;

// Define storage buffer layout for output vertices
layout(std140, binding = 1) buffer LocalVertexBufferRead {
    Vtx vtx[];
}localVertexBufferRead;

// Define storage buffer layout for transform matrices
layout(std140, binding = 2) buffer TransformSSBOData {
    TransformMatrices transformMatrices;
}transformSSBO;

struct GeometryData{
    double textureIndexBaseColor;
    double textureIndexOcclusion;
    double textureIndexMetallicRoughness;
    double textureIndexNormal;
    double firstVertex;
    double vertexCount;
};

layout(std140, binding = 3) buffer UBO {
   GeometryData geometryData[];
}ubo;

layout(binding = 4, set = 0) uniform sampler2D textures[];

void main() {
    
    //debugPrintfEXT("compute shader test");

    //index for vertex buffer
    uint vID = gl_GlobalInvocationID.x;

    //break if index > vertex buffer length
    if (vID > localVertexBufferRead.vtx.length()) {
        return;
    }
        //index for textureIndexBaseColor
    int geometryID = -1;

    for(int i = 0; i < ubo.geometryData.length(); i++){
        if(ubo.geometryData[i].firstVertex <= vID){
            geometryID = i;
        }
        else{
            break;
        }
    }

    //declare vertex struct variable and assign value from vertex buffer
    Vtx v = localVertexBufferRead.vtx[vID];

    //position
    vec4 newPosition = vec4(v.position.xyz, 1.0f);

    v.position = vec4(newPosition.x, newPosition.y, newPosition.z, 1.0f);

    //normal
    int normalColorID = int(ubo.geometryData[geometryID].textureIndexNormal);
    
    if(normalColorID != - 1){
        vec4 normalColor = texture(textures[normalColorID], v.uv);
        vec4 calculateNormal = normalize(normalColor * 2.0f - 1.0f);
        v.normal = normalize(transformSSBO.transformMatrices.rotate * calculateNormal);
    }
    
    else{
            v.normal = normalize(transformSSBO.transformMatrices.rotate * v.normal);
    }

    //color
    int diffuseColorID = int(ubo.geometryData[geometryID].textureIndexBaseColor);

    if(diffuseColorID != -1){
        vec4 texColor = texture(textures[diffuseColorID], v.uv);
        v.inColor = texColor;
    }

    //tangent
    float w = v.tangent.w;
    v.tangent = normalize((vec4(v.tangent.xyz, 1.0f)));
    v.tangent.w = w;
    
    //assign declared vertex variable data to vertex
    modelVertexBufferWrite.vtx[vID] = v;


}