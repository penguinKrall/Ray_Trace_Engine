#version 460

#extension GL_EXT_ray_tracing : require
#extension GL_GOOGLE_include_directive : require
#extension GL_EXT_nonuniform_qualifier : require
#extension GL_EXT_buffer_reference2 : require
#extension GL_EXT_scalar_block_layout : require
#extension GL_EXT_shader_explicit_arithmetic_types_int64 : require

hitAttributeEXT vec2 attribs;
 
struct RayPayload {
    vec3 color;
    float distance;
    vec3 normal;
    float reflector;
    vec4 accumulatedColor;
    float accumulatedAlpha;
    float index;
    vec3 bgTest;
    int semiTransparentFlag;
    vec4 colorID;
};

layout(location = 0) rayPayloadInEXT RayPayload rayPayload;

struct GeometryNode {
    uint64_t vertexBufferDeviceAddress;
    uint64_t indexBufferDeviceAddress;
    int textureIndexBaseColor;
    int textureIndexOcclusion;
    int textureIndexMetallicRoughness;
    int textureIndexNormal;
    int textureIndexEmissive;
    int semiTransparentFlag;
    float objectColorID;
    mat4 transforms;
};

struct GeometryIndex {
    int offset;
};

layout(binding = 4, set = 0) buffer G_Nodes_Buffer { GeometryNode nodes[]; } g_nodes_buffer;

layout(binding = 5, set = 0) buffer G_Nodes_Index { GeometryIndex indices[]; } g_nodes_indices;

layout(binding = 6, set = 0) uniform sampler2D glassTexture;

layout(binding = 8, set = 0) uniform sampler2D textures[];

#include "main_renderer_bufferreferences.glsl"
#include "main_renderer_geometrytypes.glsl"
#include "main_renderer_random.glsl"

void main() {

    uint instanceCustomIndex = gl_InstanceCustomIndexEXT;

    rayPayload.index = gl_InstanceCustomIndexEXT;

    GeometryNode geometryNode = g_nodes_buffer.nodes[gl_GeometryIndexEXT + g_nodes_indices.indices[instanceCustomIndex].offset];

    rayPayload.semiTransparentFlag = geometryNode.semiTransparentFlag;

    rayPayload.colorID = vec4(vec3(geometryNode.objectColorID), 1.0f);

    if (nonuniformEXT(geometryNode.textureIndexBaseColor) > -1) {

        Triangle tri = unpackTriangle2(gl_PrimitiveID, 112);

        vec4 color = texture(textures[nonuniformEXT(geometryNode.textureIndexBaseColor)], tri.uv);

        // Ignore intersection if the surface is fully transparent
        if (color.a < 1.0f) {

            //set transparency flag so trace rays flag is none in raygen
            if(rayPayload.semiTransparentFlag == 1){
                rayPayload.bgTest = color.rgb;
                // Composite the color with the accumulated color
                rayPayload.accumulatedColor.rgb = mix(rayPayload.accumulatedColor.rgb, color.rgb, color.a);
                rayPayload.accumulatedAlpha = mix(rayPayload.accumulatedAlpha, 1.0, color.a);
            }

            ignoreIntersectionEXT;
        }
    }

    //else{
    // rayPayload.bgTest = rayPayload.color.rgb;
    // rayPayload.accumulatedColor.rgb = rayPayload.color.rgb;
    // rayPayload.accumulatedAlpha = 1.0f;
    //}

}


