#version 450

#extension GL_EXT_debug_printf : enable

//workgroup size
layout(local_size_x = 256) in;

//vertex struct
struct Vtx {
    vec4 position;
    vec4 normal;
    vec2 uv;
    float padding;
    float padding2;
    vec4 inColor;
    vec4 inJointIndices;
    vec4 inJointWeights;
    vec4 tangent;
};

//transforms struct
struct TransformMatrices{
    mat4 rotate;
    mat4 translate;
    mat4 scale;
};

// Define storage buffer layout for input vertices and joint data
layout(std140, binding = 0) buffer InputSSBO {
    Vtx vtx[];
}inputSSBO;

// Define storage buffer layout for output vertices
layout(std140, binding = 1) buffer OutputSSBOData {
    Vtx vtx[];
}outputSSBO;

// Define storage buffer layout for transform matrices
layout(std140, binding = 2) buffer TransformSSBOData {
    TransformMatrices transformMatrices;
}transformSSBO;

void main() {
    
    //debugPrintfEXT("compute shader test");

    //index for vertex buffer
    uint vID = gl_GlobalInvocationID.x;

    //break if index > vertex buffer length
    if (vID > inputSSBO.vtx.length()) {
        return;
    }

    //declare vertex struct variable and assign value from vertex buffer
    Vtx v = outputSSBO.vtx[vID];

    //apply rotation and transformation matrices
    mat4 tMat = transformSSBO.transformMatrices.scale *
                        transformSSBO.transformMatrices.translate *
                        transformSSBO.transformMatrices.rotate;
    //position
    vec4 newPosition =  tMat *
                        vec4(v.position.xyz, 1.0f);

    v.position = vec4(newPosition.x, newPosition.y, newPosition.z, 1.0f);

    //normal
    v.normal = normalize(tMat * v.normal);
    
    //tangent
    float w = v.tangent.w;
    v.tangent = normalize((tMat * vec4(v.tangent.xyz, 1.0f)));
    v.tangent.w = w;
    
    //assign declared vertex variable data to vertex
    inputSSBO.vtx[vID] = v;


}