#version 450

#extension GL_EXT_debug_printf : enable
#extension GL_EXT_nonuniform_qualifier : require

#define MAX_GEOMETRY 100

//workgroup size
layout(local_size_x = 256) in;

//vertex struct
struct Vtx {
    vec4 position;
    vec4 normal;
    vec2 uv;
    float padding;
    float padding2;
    vec4 inColor;
    vec4 inJointIndices;
    vec4 inJointWeights;
    vec4 tangent;
};

//joint struct (bones/transformation matrices)
struct Joints{
    mat4 joint;
};

//transforms struct
struct TransformMatrices{
    mat4 rotate;
    mat4 translate;
    mat4 scale;
};

// Define storage buffer layout for input vertices and joint data
layout(std140, binding = 0) buffer InputSSBO {
    Vtx vtx[];
}inputSSBO;

// Define storage buffer layout for output vertices
layout(std140, binding = 1) buffer OutputSSBOData {
    Vtx vtx[];
}outputSSBO;

// Define storage buffer layout for joints
layout(std140, binding = 2) buffer JointSSBOData {
    Joints joints[100]; // Assuming a maximum of 20 joints
}jointSSBO;

// Define storage buffer layout for transform matrices
layout(std140, binding = 3) buffer TransformSSBOData {
    TransformMatrices transformMatrices;
}transformSSBO;

struct GeometryData{
    int textureIndexBaseColor;
    int textureIndexOcclusion;
    int textureIndexMetallicRoughness;
    int textureIndexNormal;
    int firstVertex;
    int vertexCount;
};

layout(std140, binding = 4) buffer UBO {
   GeometryData geometryData[MAX_GEOMETRY];
}ubo;

layout(binding = 5, set = 0) uniform sampler2D textures[];

void main() {

    //index for vertex buffer
    uint vID = gl_GlobalInvocationID.x;


    //break if index > vertex buffer length
    if (vID > inputSSBO.vtx.length()) {
        return;
    }
    
    //index for textureIndexBaseColor
    //int geometryID = -1;

    //for(int i = 0; i < ubo.uniformData.geometryCount; i++){
    //    if(ubo.uniformData.geometryData[i].firstVertex <= vID){
    //        geometryID = i;
    //    }
    //}

    //declare vertex struct variable and assign value from vertex buffer
    Vtx v = outputSSBO.vtx[vID];

    //joint indices
    ivec4 vJoints = ivec4(int(v.inJointIndices.x), int(v.inJointIndices.y), int(v.inJointIndices.z), int(v.inJointIndices.w));
    
    //weights
    vec4 vWeights = v.inJointWeights;
    
    //joint matrices(bones)
    Joints vBones[100] = jointSSBO.joints;

    //bone transformation matrix
    mat4 boneTransform = 
    vWeights.x * vBones[vJoints.x].joint+
    vWeights.y * vBones[vJoints.y].joint+
    vWeights.z * vBones[vJoints.z].joint+
    vWeights.w * vBones[vJoints.w].joint;
    
    //apply rotation and transformation matrices
    //position
    vec4 newPosition =  boneTransform * vec4(v.position.xyz, 1.0f);
    v.position = vec4(newPosition.x, newPosition.y, newPosition.z, 1.0f);

    //normal
    v.normal = normalize(transformSSBO.transformMatrices.rotate * boneTransform * v.normal);
    
    //color

    //int texID = inputSSBO.vtx.length() / ubo.geometryData[1].vertexCount;
    vec4 texColor = texture(textures[2], v.uv);

    //const int diffuseColorID = ubo.geometryData[2].textureIndexBaseColor;
    //vec4 texColor = texture(textures[diffuseColorID], v.uv);
    
    v.inColor = texColor;

    //tangent
    float w = v.tangent.w;
    v.tangent = normalize((boneTransform * vec4(v.tangent.xyz, 1.0f)));
    v.tangent.w = w;
    
    //assign declared vertex variable data to vertex
    inputSSBO.vtx[vID] = v;


}