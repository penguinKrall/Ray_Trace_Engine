/* Copyright (c) 2023, Sascha Willems
 *
 * SPDX-License-Identifier: MIT
 *
 */
#version 460

#extension GL_EXT_ray_tracing : require
#extension GL_GOOGLE_include_directive : require
#extension GL_EXT_nonuniform_qualifier : require
#extension GL_EXT_buffer_reference2 : require
#extension GL_EXT_scalar_block_layout : require
#extension GL_EXT_shader_explicit_arithmetic_types_int64 : require

layout(location = 0) rayPayloadInEXT vec3 hitValue;
layout(location = 3) rayPayloadInEXT uint payloadSeed;

hitAttributeEXT vec2 attribs;

layout(binding = 3, set = 0) uniform sampler2D image;

struct GeometryNode {
	uint64_t vertexBufferDeviceAddress;
	uint64_t indexBufferDeviceAddress;
	int textureIndexBaseColor;
	int textureIndexOcclusion;
};
layout(binding = 4, set = 0) buffer GeometryNodes { GeometryNode nodes[]; } geometryNodes;

struct TransformMatrix{
		mat4 matrix;
};

layout(binding = 5, set = 0 ) buffer TransformMatrices {
	TransformMatrix[] transforms;
	//glm::mat4 transforms;
} transformMatrices;

layout(binding = 6, set = 0) uniform sampler2D textures[];

#include "tfst_bufferreferences.glsl"
#include "tfst_geometrytypes.glsl"
#include "tfst_random.glsl"

void main()
{
		
	//mat4 testMat0 = transformMatrices[0].transforms.matrix;

	//mat4 testMat = jointMatrices[0];

	Triangle tri = unpackTriangle(gl_PrimitiveID, 112);
	//Triangle tri = unpackTriangle2(gl_PrimitiveID, 112);
	GeometryNode geometryNode = geometryNodes.nodes[gl_GeometryIndexEXT];
	vec4 color = texture(textures[nonuniformEXT(geometryNode.textureIndexBaseColor)], tri.uv);
		 if(rnd(payloadSeed) > color.a) {
			ignoreIntersectionEXT;
		}
}