#version 460

#extension GL_EXT_ray_tracing : require
#extension GL_GOOGLE_include_directive : require
#extension GL_EXT_nonuniform_qualifier : require
#extension GL_EXT_buffer_reference2 : require
#extension GL_EXT_scalar_block_layout : require
#extension GL_EXT_shader_explicit_arithmetic_types_int64 : require

hitAttributeEXT vec2 attribs;

struct RayPayload {
    vec3 color;
    float distance;
    vec3 normal;
    float reflector;
    //vec4 rgbaColorData;
    vec4 accumulatedColor;
    float accumulatedAlpha;
    float index;
    vec3 bgTest;
};

layout(location = 0) rayPayloadInEXT RayPayload rayPayload;

struct GeometryNode {
    uint64_t vertexBufferDeviceAddress;
    uint64_t indexBufferDeviceAddress;
    int textureIndexBaseColor;
    int textureIndexOcclusion;
};

struct GeometryIndex {
    int offset;
};

layout(binding = 3, set = 0) buffer G_Nodes_Buffer { GeometryNode nodes[]; } g_nodes_buffer;

layout(binding = 4, set = 0) buffer G_Nodes_Index { GeometryIndex indices[]; } g_nodes_indices;

layout(binding = 5, set = 0) uniform sampler2D glassTexture;

layout(binding = 6, set = 0) uniform sampler2D textures[];

#include "build_scene_bufferreferences.glsl"
#include "build_scene_geometrytypes.glsl"
#include "build_scene_random.glsl"

void main() {
    uint instanceCustomIndex = gl_InstanceCustomIndexEXT;
    GeometryNode geometryNode = g_nodes_buffer.nodes[gl_GeometryIndexEXT + g_nodes_indices.indices[instanceCustomIndex].offset];

    if (nonuniformEXT(geometryNode.textureIndexBaseColor) > -1) {
        Triangle tri = unpackTriangle2(gl_PrimitiveID, 112);
        vec4 color = texture(textures[nonuniformEXT(geometryNode.textureIndexBaseColor)], tri.uv);

        // Ignore intersection if the surface is fully transparent
        if (color.a < 1.0f) {
            ignoreIntersectionEXT;
        }
    }

    if (gl_InstanceCustomIndexEXT == 2) {
        Triangle tri = unpackTriangle2(gl_PrimitiveID, 112);
        vec4 color = texture(glassTexture, tri.uv);

        // Composite the color with the accumulated color
        rayPayload.accumulatedColor.rgb = mix(rayPayload.accumulatedColor.rgb, color.rgb, color.a);
        rayPayload.accumulatedAlpha = mix(rayPayload.accumulatedAlpha, 1.0, color.a);

        // Ignore intersection if the surface is fully transparent
        if (color.a < 1.0f) {
            ignoreIntersectionEXT;
        }
    }

    rayPayload.index = gl_InstanceCustomIndexEXT;

}


