#version 450

//workgroup size
layout(local_size_x = 256) in;

//vertex struct
struct Vtx {
    vec4 position;
    vec4 normal;
    vec2 uv;
    float padding;
    float padding2;
    vec4 inColor;
    vec4 inJointIndices;
    vec4 inJointWeights;
    vec4 tangent;
};

//joint struct (bones/transformation matrices)
struct Joints{
    mat4 joint;
};

//transforms struct
struct TransformMatrices{
    mat4 rotate;
    mat4 translate;
    mat4 scale;
};

// Define storage buffer layout for input vertices and joint data
layout(std140, binding = 0) buffer InputSSBO {
    Vtx vtx[];
}inputSSBO;

// Define storage buffer layout for output vertices
layout(std140, binding = 1) buffer OutputSSBOData {
    Vtx vtx[];
}outputSSBO;

// Define storage buffer layout for joints
layout(std140, binding = 2) buffer JointSSBOData {
    Joints joints[100]; // Assuming a maximum of 20 joints
}jointSSBO;

// Define storage buffer layout for transform matrices
layout(std140, binding = 3) buffer TransformSSBOData {
    TransformMatrices transformMatrices;
}transformSSBO;

void main() {
    
    //index for vertex buffer
    uint vID = gl_GlobalInvocationID.x;

    //break if index > vertex buffer length
    if (vID > inputSSBO.vtx.length()) {
        return;
    }

    //declare vertex struct variable and assign value from vertex buffer
    Vtx v = outputSSBO.vtx[vID];

    // Translation matrix along x-axis
    float translateX = -15.0; // Adjust the translation amount as needed
    mat4 translationMatrix = mat4(1.0);
    translationMatrix[3][0] = translateX;

    //rotation matrix to rotate vertex around x axis
    //float angle = radians(90.0); // Adjust the angle as needed
    //mat4 rotationMatrix = mat4(1.0);
    //rotationMatrix[1][1] = cos(angle);
    //rotationMatrix[1][2] = -sin(angle);
    //rotationMatrix[2][1] = sin(angle);
    //rotationMatrix[2][2] = cos(angle);

    // Rotation matrix around z-axis
    //float angle = radians(90.0); // Adjust the angle as needed
    //mat4 rotationMatrix = mat4(1.0);
    //rotationMatrix[0][0] = cos(angle);
    //rotationMatrix[0][1] = -sin(angle);
    //rotationMatrix[1][0] = sin(angle);
    //rotationMatrix[1][1] = cos(angle);

    // Rotation matrix around y-axis
    float angle = radians(90.0); // Adjust the angle as needed
    mat4 rotationMatrix = mat4(1.0);
    rotationMatrix[0][0] = cos(angle);
    rotationMatrix[0][2] = sin(angle);
    rotationMatrix[2][0] = -sin(angle);
    rotationMatrix[2][2] = cos(angle);

    // Scale down factor
    float scaleDownFactor = 0.05; // Example scale down factor

    // Scaling matrix
    mat4 scaleMatrix = mat4(1.0);
    scaleMatrix[0][0] = scaleDownFactor;
    scaleMatrix[1][1] = scaleDownFactor;
    scaleMatrix[2][2] = scaleDownFactor;

    //joint indices
    ivec4 vJoints = ivec4(int(v.inJointIndices.x), int(v.inJointIndices.y), int(v.inJointIndices.z), int(v.inJointIndices.w));
    
    //weights
    vec4 vWeights = v.inJointWeights;
    
    //joint matrices(bones)
    Joints vBones[100] = jointSSBO.joints;

    //bone transformation matrix
    mat4 boneTransform = 
    vWeights.x * vBones[vJoints.x].joint+
    vWeights.y * vBones[vJoints.y].joint+
    vWeights.z * vBones[vJoints.z].joint+
    vWeights.w * vBones[vJoints.w].joint;
    
    //apply rotation and transformation matrices
    //position
    vec4 newPosition =  boneTransform * vec4(v.position.xyz, 1.0f);
    v.position = vec4(newPosition.x, newPosition.y, newPosition.z, 1.0f);
    //transformSSBO.transformMatrices.translate * transformSSBO.transformMatrices.rotate * transformSSBO.transformMatrices.scale * boneTransform * vec4(v.position.xyz, 1.0f);
    //v.position = vec4(newPosition.x, newPosition.y, newPosition.z, 1.0f);


    
    //normal
    v.normal = normalize(boneTransform * v.normal);
    
    //tangent
    float w = v.tangent.w;
    v.tangent = normalize((boneTransform * vec4(v.tangent.xyz, 1.0f)));
    v.tangent.w = w;
    
    //assign declared vertex variable data to vertex
    inputSSBO.vtx[vID] = v;


}